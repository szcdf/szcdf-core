#!/usr/bin/env bash
###############################################################################
#
# Package: szcdf-core
# Author: Stephen Zhao (mail@zhaostephen.com)
# Type: Module
# Module: text_section_syncer
# Purpose: Provides text section syncing functionality.
#
# To load this module, run
# ```bash
# szcdf_module_manager load text_section_syncer
# ```

######### MAIN ################################################################

# $# >= 1
# $1 = ensure_text_section_or_prepend | ensure_text_section_or_append
# $:2 = additional args depending on subcommand
szcdf_text_section_syncer() {
  szcdf_logging__begin_context 'szcdf_text_section_syncer'

  local subcommand=$1
  shift

  case $subcommand in
    ensure_text_section_or_prepend)
      szcdf_text_section_syncer__ensure_text_section_or_prepend "$@"
      ;;
    ensure_text_section_or_append)
      szcdf_text_section_syncer__ensure_text_section_or_append "$@"
      ;;
    *)
      szcdf_logging__error "Invalid subcommand: $subcommand"
      ;;
  esac

  szcdf_logging__end_context
}

######### SYNC FUNCTIONS ######################################################

# $# >= 3
# $1 = dest_file_path
# $2 = src_file_path
# $3 = text_section_id
# $4 = comment_indicator (optional)
szcdf_text_section_syncer__ensure_text_section_or_prepend() {
  local dest_file_path=$1
  local src_file_path=$2
  local text_section_id=$3
  local comment_indicator=$4
  shift
  shift
  shift
  shift

  if [[ -z "$comment_indicator" ]]; then
    comment_indicator='#'
  fi

  szcdf_logging__debug "Ensuring text section $text_section_id in $dest_file_path."

  if [[ ! -f "$src_file_path" ]]; then
    szcdf_logging__error "Source file $src_file_path does not exist."
    return 1
  fi

  local begin_marker
  local end_marker
  begin_marker="$comment_indicator >>>>>>> SZCDF_TEXT_SECTION // BEGIN SECTION_ID=$text_section_id // THIS SECTION IS GENERATED BY SZCDF // DO NOT EDIT MANUALLY"
  end_marker="$comment_indicator <<<<<<< SZCDF_TEXT_SECTION // END SECTION_ID=$text_section_id // THIS SECTION IS GENERATED BY SZCDF // DO NOT EDIT MANUALLY"

  # If destination exists and contains the section, replace its contents
  if [[ -f "$dest_file_path" ]] \
    && grep -F -q -- "$begin_marker" "$dest_file_path" \
    && grep -F -q -- "$end_marker" "$dest_file_path"; then

    local tmp_file
    tmp_file="$(mktemp)"

    awk -v b="$begin_marker" -v e="$end_marker" -v src_file="$src_file_path" '
      BEGIN { in_section = 0 }
      $0 == b {
        print $0
        while ((getline line < src_file) > 0) {
          print line
        }
        close(src_file)
        in_section = 1
        next
      }
      in_section {
        if ($0 == e) {
          print $0
          in_section = 0
        }
        next
      }
      { print $0 }
    ' "$dest_file_path" > "$tmp_file"

    mv "$tmp_file" "$dest_file_path"

  else
    # Otherwise, prepend a new section to the top of the file
    local tmp_file
    tmp_file="$(mktemp)"

    {
      printf "%s\n" "$begin_marker"
      cat "$src_file_path"
      printf "%s\n" "$end_marker"
      if [[ -f "$dest_file_path" ]]; then
        cat "$dest_file_path"
      fi
    } > "$tmp_file"

    mv "$tmp_file" "$dest_file_path"
  fi

  return 0
}

# $# >= 3
# $1 = dest_file_path
# $2 = src_file_path
# $3 = text_section_id
# $4 = comment_indicator (optional)
szcdf_text_section_syncer__ensure_text_section_or_append() {
  local dest_file_path=$1
  local src_file_path=$2
  local text_section_id=$3
  local comment_indicator=$4
  shift
  shift
  shift
  shift

  if [[ -z "$comment_indicator" ]]; then
    comment_indicator='#'
  fi

  szcdf_logging__debug "Ensuring text section $text_section_id in $dest_file_path."

  if [[ ! -f "$src_file_path" ]]; then
    szcdf_logging__error "Source file $src_file_path does not exist."
    return 1
  fi

  local begin_marker
  local end_marker
  begin_marker="$comment_indicator >>>>>>> SZCDF_TEXT_SECTION // BEGIN SECTION_ID=$text_section_id // THIS SECTION IS GENERATED BY SZCDF // DO NOT EDIT MANUALLY"
  end_marker="$comment_indicator <<<<<<< SZCDF_TEXT_SECTION // END SECTION_ID=$text_section_id // THIS SECTION IS GENERATED BY SZCDF // DO NOT EDIT MANUALLY"

  # If destination exists and contains the section, replace its contents
  if [[ -f "$dest_file_path" ]] \
    && grep -F -q -- "$begin_marker" "$dest_file_path" \
    && grep -F -q -- "$end_marker" "$dest_file_path"; then

    local tmp_file
    tmp_file="$(mktemp)"

    awk -v b="$begin_marker" -v e="$end_marker" -v src_file="$src_file_path" '
      BEGIN { in_section = 0 }
      $0 == b {
        print $0
        while ((getline line < src_file) > 0) {
          print line
        }
        close(src_file)
        in_section = 1
        next
      }
      in_section {
        if ($0 == e) {
          print $0
          in_section = 0
        }
        next
      }
      { print $0 }
    ' "$dest_file_path" > "$tmp_file"

    mv "$tmp_file" "$dest_file_path"

  else
    # Otherwise, append a new section to the end of the file
    local tmp_file
    tmp_file="$(mktemp)"

    if [[ -f "$dest_file_path" ]]; then
      cat "$dest_file_path" > "$tmp_file"
    fi

    {
      printf "%s\n" "$begin_marker"
      cat "$src_file_path"
      printf "%s\n" "$end_marker"
    } >> "$tmp_file"

    mv "$tmp_file" "$dest_file_path"
  fi

  return 0
}


######### CLEANUP #############################################################

# $# = 0
szcdf_text_section_syncer__cleanup() {
  unset -f szcdf_text_section_syncer

  unset -f szcdf_text_section_syncer__ensure_text_section_or_prepend
  unset -f szcdf_text_section_syncer__ensure_text_section_or_append

  unset -f szcdf_text_section_syncer__cleanup
}
